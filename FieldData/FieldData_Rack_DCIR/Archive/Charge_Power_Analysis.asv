%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Rack Data DCIR Charge
% Charging event extraction and impedance, power analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clc; clear; close all;

%% Directory - Multiple years
dataDir = 'D:\JCW\Projects\KEPCO_ESS_Local\Rack_raw2mat\New';
saveDir = fullfile('D:\JCW\Projects\KEPCO_ESS_Local\FieldData\FieldData_Rack_DCIR\Charge\Charge_Power_Analysis');
%% 
if ~exist(saveDir, 'dir')
    mkdir(saveDir);
end

%% Parameters 
% Battery pack capacity [Ah]
C_nom_rack = 128;               % Ah
P_nom_rack = 112;               % 3.68*64/1000 [kW] | 0.23552 * 2P * 14S * 17S = 112
idle_thr = C_nom_rack * 0.1;   % Initial current threshold (A)
min_duration = 300;             % [s] - Charging duration (300 seconds or more)
max_P_std = P_nom_rack * 0.0001; % Max power standard deviation [kW] 0.0112kW 
max_I_std = C_nom_rack * 0.01; % Max current standard deviation [A] 1.28A 

% Event similarity filtering parameters
% Fixed voltage bins for charging start voltage
V_bins = 3.6:0.1:3.9;           % [V] - Fixed voltage bins (3.6V ~ 3.9V, 0.1V intervals)
P_similarity_threshold = 0.05;  % [%] - Power similarity threshold (5%)
min_events_per_year = 5;        % Minimum number of events per year for visualization

% Sampling time [s]
Ts = 1;

%% Initialize data structures
% Year-based data structure: year -> month -> events
yearly_data = struct();
event_counter = 0;

% Store actual event data for plotting
all_events_data = struct();
all_events_data.t = {};
all_events_data.I = {};
all_events_data.V = {};
all_events_data.year = [];
all_events_data.month = [];
all_events_data.R0_instant = {};
all_events_data.P_loss_instant = {};
all_events_data.eta_loss_instant = {};
all_events_data.V_start = [];
all_events_data.V_fin = [];
all_events_data.P_avg = [];



%% Folder traversal - Multiple years
yearDirs = dir(fullfile(dataDir, '20*'));
for y = 1:length(yearDirs)
    if ~yearDirs(y).isdir
        continue;
    end
    yearPath = fullfile(dataDir, yearDirs(y).name);
    
    % Extract year number
    year_name = yearDirs(y).name;
    yearnum = str2num(year_name);
    fprintf('Processing year: %d\n', yearnum);
    
    % Initialize yearly data structure
    year_key = sprintf('year_%04d', yearnum);
    yearly_data.(year_key) = struct();
    yearly_data.(year_key).events_count = 0;
    
    % Get month directories for this year
    monthDirs = dir(fullfile(yearPath, '20*'));
    for m = 1:length(monthDirs)
        if ~monthDirs(m).isdir
            continue;
        end
        monthPath = fullfile(yearPath, monthDirs(m).name);
        matFiles = dir(fullfile(monthPath, '*.mat'));

        % Extract month number from folder name (handle different naming formats)
        folder_name = monthDirs(m).name;
        if length(folder_name) >= 6
            monthnum = str2num(folder_name(5:6));
        elseif length(folder_name) >= 2
            monthnum = str2num(folder_name(end-1:end));
        else
            fprintf('Warning: Cannot parse month from folder name: %s\n', folder_name);
            continue;
        end
        fprintf('Processing year %d, month: %d (%d files)\n', yearnum, monthnum, length(matFiles));
        
        % Initialize monthly data structure within year
        month_key = sprintf('month_%02d', monthnum);
        yearly_data.(year_key).(month_key) = struct();
        yearly_data.(year_key).(month_key).events = struct();
        yearly_data.(year_key).(month_key).events_count = 0;
    

    
    for f = 1:length(matFiles)
        fprintf('Processing daily file: %s (%d/%d)\n', matFiles(f).name, f, length(matFiles));
        matFilePath = fullfile(monthPath, matFiles(f).name);
        load(matFilePath);    

        % Extract data from Raw structure
        t = Raw.Date_Time_seconds;
        I = Raw.DCCurrent;
        V_raw = Raw.CVavg;
        T_batt = Raw.MTavg;
        soc = Raw.SOC_BMS;
        
        % Apply moving average to voltage to reduce noise (window=50)
        V = movmean(V_raw, 20);
        
        % Calculate power using smoothed voltage
        P = V .* I / 1000; % Convert to kW
        
        %% Event extraction: Idle to Charging transition
        % Find idle periods (low current)
        is_idle = abs(I) < idle_thr;
        is_charging = I > idle_thr;
        
        % Find transitions from idle to charging
        idle_to_charge = find(is_idle(1:end-1) & is_charging(2:end));
        
        %% Process each charging event
        for i = 1:length(idle_to_charge)
            start_idx = idle_to_charge(i);
            start_charge_idx = start_idx + 1;
            
            % Find end of charging period
            end_idx = start_charge_idx;
            while end_idx <= length(is_charging) && is_charging(end_idx)
                end_idx = end_idx + 1;
            end
            end_idx = end_idx - 3; % 1 second before charging end
            
            % Check charging duration
            charge_duration = end_idx - start_charge_idx + 1;
            if charge_duration < min_duration
                continue;
            end
            
            % Extract event data
            t_seg = t(start_idx:end_idx);
            I_seg = I(start_idx:end_idx);
            V_seg = V(start_idx:end_idx);
            P_seg = P(start_idx:end_idx);
            T_seg = T_batt(start_idx:end_idx);
            soc_seg = soc(start_idx:end_idx);
            
            % Check stability
            power_std = std(P_seg(3:end-3));
            current_std = std(I_seg(3:end-3));
            
            if power_std > max_P_std || current_std > max_I_std
                continue;
            end

            % if current_std > max_I_std
            %     continue;
            % end

            %% Calculate R₀ for entire event duration (time-varying)
            % Calculate R₀ for each time point using start point as reference
            % R₀(t) = [V(t) - V(start)] / [I(t) - I(start)] - t 시점 기준
            % 전체 이벤트 기간 동안 매 1초마다 계산
            R0_instant = zeros(size(I_seg));
            
            % Get charging start indices
            charging_start_rel = start_charge_idx - start_idx + 1;
            
            for k = 1:length(I_seg)
                V1 = V_seg(1);  % V(start) - idle 구간 마지막
                V2 = V_seg(k);  % V(t) - 현재 시점
                I1 = I_seg(1);  % I(start) - idle 구간 마지막
                I2 = I_seg(k);  % I(t) - 현재 시점
                dV = V2 - V1;
                dI = I2 - I1;
                
                if dI ~= 0  % 0으로 나누기 방지
                    R0_instant(k) = dV / dI; % [Ω] - t 시점의 R₀
                else
                    R0_instant(k) = NaN;
                end
            end
            
            % Apply moving average to smooth R₀ values
            R0_smoothed = movmean(R0_instant, 20);
            
            % Check if we have valid R₀ values
            valid_R0 = R0_smoothed(~isnan(R0_smoothed));
            if isempty(valid_R0)
                continue; % Skip events with no valid R₀
            end
            
            % Use first valid R₀ as representative value for monthly averages
            R0_rep = valid_R0(1);
            
            %% Calculate power loss and efficiency metrics (time-varying)
            % Calculate P_loss and η_loss for each time point using Ts-second intervals
            % P_loss(t) = I(t)² × R₀(t), η_loss(t) = R₀(t) / Z(t) - t 시점 기준
            % 전체 이벤트 기간 동안 매 Ts초마다 계산
            P_loss_instant = zeros(size(I_seg));
            eta_loss_instant = zeros(size(I_seg));
            
            for k = 1:length(I_seg)
                % Calculate impedance: Z(t) = V(t)/I(t) (at t time point)
                Z_instant_k = V_seg(k) / I_seg(k);
                
                % Calculate power loss: P_loss(t) = I(t)² × R₀(t) (at t time point)
                P_loss_instant(k) = (I_seg(k)^2) * R0_smoothed(k) / 1000; % Convert to kW
                
                % Calculate loss ratio: η_loss(t) = R₀(t) / Z(t) (at t time point)
                if Z_instant_k > 0
                    eta_loss_instant(k) = R0_smoothed(k) / Z_instant_k;
                else
                    eta_loss_instant(k) = NaN;
                end
            end
            
            % Get representative values (average of charging period)
            charging_start_rel = start_charge_idx - start_idx + 1;
            V_charging = V_seg(charging_start_rel:end);
            I_charging = I_seg(charging_start_rel:end);
            P_charging = P_seg(charging_start_rel:end);
            T_charging = T_seg(charging_start_rel:end);
            
            V_rep = mean(V_charging);
            I_rep = mean(I_charging);
            T_rep = mean(T_charging);
            P_rep = mean(P_charging);
            eta_loss_rep = mean(eta_loss_instant(~isnan(eta_loss_instant)));
            
            % Get charging start voltage, end voltage and average power for similarity filtering
            V1 = V_seg(charging_start_rel);  % Charging start voltage
            V_fin = V_seg(end);              % Charging end voltage
            P_avg = mean(P_charging(3:end-3));    % Average power (excluding first/last 3 points)
            
            %% Store results
            event_counter = event_counter + 1;
            
            % Store event data in yearly_data structure: year -> month -> events
            event_key = sprintf('event_%03d', yearly_data.(year_key).(month_key).events_count + 1);
            yearly_data.(year_key).(month_key).events.(event_key) = struct();
            
            % Store reference values for R₀ calculation
            yearly_data.(year_key).(month_key).events.(event_key).V1 = V1;  % V(start)
            yearly_data.(year_key).(month_key).events.(event_key).V2 = V_seg(end);  % V(end)
            yearly_data.(year_key).(month_key).events.(event_key).I1 = I1;  % I(start)
            yearly_data.(year_key).(month_key).events.(event_key).I2 = I_seg(end);  % I(end)
            
            % Store time series data
            yearly_data.(year_key).(month_key).events.(event_key).T_seq = T_seg;
            yearly_data.(year_key).(month_key).events.(event_key).V_seq = V_seg;
            yearly_data.(year_key).(month_key).events.(event_key).I_seq = I_seg;
            yearly_data.(year_key).(month_key).events.(event_key).P_seq = P_seg;
            yearly_data.(year_key).(month_key).events.(event_key).R0_seq = R0_smoothed;
            yearly_data.(year_key).(month_key).events.(event_key).P_loss_seq = P_loss_instant;
            yearly_data.(year_key).(month_key).events.(event_key).eta_loss_seq = eta_loss_instant;
            
            % Store condition values for similarity filtering
            yearly_data.(year_key).(month_key).events.(event_key).V_start = V1;
            yearly_data.(year_key).(month_key).events.(event_key).V_fin = V_fin;
            yearly_data.(year_key).(month_key).events.(event_key).P_avg_condition = P_avg;
            
            % Update event counts
            yearly_data.(year_key).(month_key).events_count = yearly_data.(year_key).(month_key).events_count + 1;
            yearly_data.(year_key).events_count = yearly_data.(year_key).events_count + 1;
            
            % Store actual event data for plotting (normalize time to start from 0)
            t_normalized = t_seg - t_seg(1); % Start from 0 seconds
            all_events_data.t{end+1} = t_normalized;
            all_events_data.I{end+1} = I_seg;
            all_events_data.V{end+1} = V_seg;
            all_events_data.year = [all_events_data.year, yearnum];
            all_events_data.month = [all_events_data.month, monthnum];
            all_events_data.R0_instant = [all_events_data.R0_instant, R0_instant];
            all_events_data.P_loss_instant = [all_events_data.P_loss_instant, P_loss_instant];
            all_events_data.eta_loss_instant = [all_events_data.eta_loss_instant, eta_loss_instant];
            all_events_data.V_start = [all_events_data.V_start, V1];
            all_events_data.V_fin = [all_events_data.V_fin, V_fin];
            all_events_data.P_avg = [all_events_data.P_avg, P_avg];
            

            
            fprintf('Event %d: R₀=%.4f Ω, η_loss=%.4f, V_avg=%.2f V\n', ...
                event_counter, R0_rep, eta_loss_rep, V_rep);
        end
    end
    

    
        fprintf('Year %d, Month %d: %d events processed\n', yearnum, monthnum, yearly_data.(year_key).(month_key).events_count);
    end
    fprintf('Year %d: Total %d events processed\n', yearnum, yearly_data.(year_key).events_count);
end

%% Event similarity filtering function - Find common conditions across all years using V_start and V_fin ranges
function [common_conditions, filtered_events_by_year] = find_common_similar_conditions(all_events_data, V_bins)
    % Find charging conditions that exist across all years with same V_start and V_fin ranges
    year_list = unique(all_events_data.year);
    n_years = length(year_list);
    
    % Get all V_start and V_fin values
    all_V_starts = all_events_data.V_start;
    all_V_fins = all_events_data.V_fin;
    
    % Find unique condition clusters using V_start and V_fin bins
    common_conditions = [];
    filtered_events_by_year = struct();
    
    % For each V_start bin, check if similar conditions exist across all years
    for v_start_bin = 1:(length(V_bins)-1)
        V_start_bin_start = V_bins(v_start_bin);
        V_start_bin_end = V_bins(v_start_bin + 1);
        V_start_bin_center = (V_start_bin_start + V_start_bin_end) / 2;
        
        % For each V_fin bin
        for v_fin_bin = 1:(length(V_bins)-1)
            V_fin_bin_start = V_bins(v_fin_bin);
            V_fin_bin_end = V_bins(v_fin_bin + 1);
            V_fin_bin_center = (V_fin_bin_start + V_fin_bin_end) / 2;
            
            % Find events in this V_start and V_fin bin combination
            events_in_condition = find(all_V_starts >= V_start_bin_start & all_V_starts < V_start_bin_end & ...
                                     all_V_fins >= V_fin_bin_start & all_V_fins < V_fin_bin_end);
            
            if isempty(events_in_condition)
                continue; % Skip if no events in this condition
            end
            
            % Check if this condition exists in all years
            condition_exists_in_all_years = true;
            yearly_event_counts = zeros(1, n_years);
            
            for y = 1:n_years
                yearnum = year_list(y);
                year_events_idx = find(all_events_data.year == yearnum);
                
                if isempty(year_events_idx)
                    condition_exists_in_all_years = false;
                    break;
                end
                
                % Get events for this year
                V_starts_year = all_events_data.V_start(year_events_idx);
                V_fins_year = all_events_data.V_fin(year_events_idx);
                
                % Find events in this year that fall within this condition
                similar_in_year = [];
                for j = 1:length(year_events_idx)
                    V_start_in_bin = V_starts_year(j) >= V_start_bin_start && V_starts_year(j) < V_start_bin_end;
                    V_fin_in_bin = V_fins_year(j) >= V_fin_bin_start && V_fins_year(j) < V_fin_bin_end;
                    
                    if V_start_in_bin && V_fin_in_bin
                        similar_in_year = [similar_in_year, year_events_idx(j)];
                    end
                end
                
                yearly_event_counts(y) = length(similar_in_year);
                
                % Check if this year has at least one event (no minimum requirement)
                if length(similar_in_year) == 0
                    condition_exists_in_all_years = false;
                    break;
                end
            end
            
            % If condition exists in all years, add to common conditions
            if condition_exists_in_all_years
                condition_idx = length(common_conditions) + 1;
                common_conditions(condition_idx).V_start_bin_start = V_start_bin_start;
                common_conditions(condition_idx).V_start_bin_end = V_start_bin_end;
                common_conditions(condition_idx).V_start_bin_center = V_start_bin_center;
                common_conditions(condition_idx).V_fin_bin_start = V_fin_bin_start;
                common_conditions(condition_idx).V_fin_bin_end = V_fin_bin_end;
                common_conditions(condition_idx).V_fin_bin_center = V_fin_bin_center;
                common_conditions(condition_idx).events = events_in_condition;
                common_conditions(condition_idx).yearly_event_counts = yearly_event_counts;
                common_conditions(condition_idx).total_events = sum(yearly_event_counts);
                
                % Organize events by year
                for y = 1:n_years
                    yearnum = year_list(y);
                    year_field = sprintf('year_%d', yearnum);
                    year_events = events_in_condition(all_events_data.year(events_in_condition) == yearnum);
                    filtered_events_by_year(condition_idx).(year_field) = year_events;
                end
            
            end
        end
    end
    
    % Sort conditions by total number of events (descending)
    if ~isempty(common_conditions)
        [~, sort_idx] = sort([common_conditions.total_events], 'descend');
        common_conditions = common_conditions(sort_idx);
        filtered_events_by_year = filtered_events_by_year(sort_idx);
    end
end

%% Find common similar conditions across all years
[common_conditions, filtered_events_by_year] = find_common_similar_conditions(all_events_data, V_bins);

fprintf('\nFound %d common charging conditions across all years:\n', length(common_conditions));
for i = 1:length(common_conditions)
    year_list = unique(all_events_data.year);
    fprintf('Condition %d: V_start=%.3f-%.3fV (center=%.3fV), V_fin=%.3f-%.3fV (center=%.3fV) (Total: %d events)\n', ...
    i, common_conditions(i).V_start_bin_start, common_conditions(i).V_start_bin_end, common_conditions(i).V_start_bin_center, ...
    common_conditions(i).V_fin_bin_start, common_conditions(i).V_fin_bin_end, common_conditions(i).V_fin_bin_center, ...
    common_conditions(i).total_events);
    for y = 1:length(year_list)
        yearnum = year_list(y);
        fprintf('  Year %d: %d events\n', yearnum, common_conditions(i).yearly_event_counts(y));
    end
end

%% Figure 1: Best common charging condition - Time vs Current/Voltage (only if common conditions exist)
if ~isempty(common_conditions)
    % Use only the first (best) common condition (most events)
    cond_idx = 1;
    condition = common_conditions(cond_idx);
    
    year_list = unique(all_events_data.year);
    n_years = length(year_list);
    
    % Create separate figures for each year
    for y = 1:n_years
        yearnum = year_list(y);
        year_field = sprintf('year_%d', yearnum);
        year_events_idx = filtered_events_by_year(cond_idx).(year_field);
        
        if ~isempty(year_events_idx)
            figure('Position', [100, 100, 1400, 800]);
            
            % Subplot 1: Current vs Time for this year
            subplot(2, 1, 1);
            hold on;
            colors = lines(length(year_events_idx));
            
            for j = 1:length(year_events_idx)
                event_idx = year_events_idx(j);
                plot(all_events_data.t{event_idx}, all_events_data.I{event_idx}, ...
                    'Color', colors(j, :), 'LineWidth', 1.5, ...
                    'DisplayName', sprintf('Event %d', j));
            end
            
            xlabel('Time (s)');
            ylabel('Current (A)');
            title(sprintf('Year %d - Best Common Condition: V_start=%.3f-%.3fV, V_fin=%.3f-%.3fV - Current vs Time (n=%d)', ...
                yearnum, condition.V_start_bin_start, condition.V_start_bin_end, condition.V_fin_bin_start, condition.V_fin_bin_end, length(year_events_idx)));
            grid on;
            % legend('Location', 'best');
            
            % Subplot 2: Voltage vs Time for this year
            subplot(2, 1, 2);
            hold on;
            
            for j = 1:length(year_events_idx)
                event_idx = year_events_idx(j);
                plot(all_events_data.t{event_idx}, all_events_data.V{event_idx}, ...
                    'Color', colors(j, :), 'LineWidth', 1.5, ...
                    'DisplayName', sprintf('Event %d', j));
            end
            
            xlabel('Time (s)');
            ylabel('Voltage (V)');
            title(sprintf('Year %d - Best Common Condition: V_start=%.3f-%.3fV, V_fin=%.3f-%.3fV - Voltage vs Time (n=%d)', ...
                yearnum, condition.V_start_bin_start, condition.V_start_bin_end, condition.V_fin_bin_start, condition.V_fin_bin_end, length(year_events_idx)));
            grid on;
            % legend('Location', 'best');
            
            % Save figure for this year
            saveas(gcf, fullfile(saveDir, sprintf('best_common_condition_time_series_year_%d.fig', yearnum)));
        end
    end
else
    fprintf('No common charging conditions found across all years. Skipping Figure 1.\n');
end

%% Figure 2: All common charging conditions - R₀, P_loss, η_loss vs Time (Yearly basis)
if ~isempty(common_conditions)
    % Process all common conditions
    for cond_idx = 1:length(common_conditions)
        condition = common_conditions(cond_idx);
    
    year_list = unique(all_events_data.year);
    n_years = length(year_list);
    
    figure('Position', [100, 100, 1400, 800]);
    
    for y = 1:n_years
        yearnum = year_list(y);
        year_field = sprintf('year_%d', yearnum);
        year_events_idx = filtered_events_by_year(cond_idx).(year_field);
        
        if ~isempty(year_events_idx)
            % Subplot 1: R₀ vs Time for this year
            subplot(3, n_years, y);
            hold on;
            colors = lines(length(year_events_idx));
            
            for j = 1:length(year_events_idx)
                event_idx = year_events_idx(j);
                % R₀ varies with time - plot only valid values (exclude NaN)
                t_event = all_events_data.t{event_idx};
                R0_event = all_events_data.R0_instant{event_idx};
                
                % Find valid (non-NaN) values
                valid_idx = ~isnan(R0_event);
                if any(valid_idx)
                    plot(t_event(valid_idx), R0_event(valid_idx), 'o', 'Color', colors(j, :), 'LineWidth', 0.8, 'DisplayName', sprintf('Event %d', j));
                end
            end
            
            xlabel('Time (s)');
            ylabel('R₀ (Ω)');
            title(sprintf('Year %d - R₀ vs Time (n=%d)', yearnum, length(year_events_idx)));
            grid on;
            
            % Subplot 2: P_loss vs Time for this year
            subplot(3, n_years, y + n_years);
            hold on;
            
            for j = 1:length(year_events_idx)
                event_idx = year_events_idx(j);
                % P_loss varies with time - plot only valid values (exclude NaN)
                t_event = all_events_data.t{event_idx};
                P_loss_event = all_events_data.P_loss_instant{event_idx};
                
                % Find valid (non-NaN) values
                valid_idx = ~isnan(P_loss_event);
                if any(valid_idx)
                    plot(t_event(valid_idx), P_loss_event(valid_idx), 'o', ...
                        'Color', colors(j, :), 'LineWidth', 0.8, ...
                        'DisplayName', sprintf('Event %d', j));
                end
            end
            
            xlabel('Time (s)');
            ylabel('P_{loss} (kW)');          
            title(sprintf('Year %d - P_{loss} vs Time (n=%d)', yearnum, length(year_events_idx)));
            grid on;
            
            % Subplot 3: η_loss vs Time for this year
            subplot(3, n_years, y + 2*n_years);
            hold on;
            
            for j = 1:length(year_events_idx)
                event_idx = year_events_idx(j);
                % η_loss varies with time - plot only valid values (exclude NaN)
                t_event = all_events_data.t{event_idx};
                eta_loss_event = all_events_data.eta_loss_instant{event_idx};
                
                % Find valid (non-NaN) values
                valid_idx = ~isnan(eta_loss_event);
                if any(valid_idx)
                    plot(t_event(valid_idx), eta_loss_event(valid_idx), 'o-', ...
                        'Color', colors(j, :), 'LineWidth', 1.5, ...
                        'DisplayName', sprintf('Event %d', j));
                end
            end
            
            xlabel('Time (s)');
            ylabel('η_{loss}');            
            title(sprintf('Year %d - η_{loss} vs Time (n=%d)', yearnum, length(year_events_idx)));
            grid on;
        end
    end
    
        sgtitle(sprintf('Common Condition %d: V_start=%.3f-%.3fV, V_fin=%.3f-%.3fV (Total: %d events)', ...
            cond_idx, condition.V_start_bin_start, condition.V_start_bin_end, condition.V_fin_bin_start, condition.V_fin_bin_end, condition.total_events));
        saveas(gcf, fullfile(saveDir, sprintf('common_condition_%d_R0_Ploss_etaloss_timeseries.fig', cond_idx)));
    end
else
    fprintf('No common charging conditions found across all years. Skipping Figure 2.\n');
end

%% Figure 3: All common charging conditions - Monthly comparison of R₀, P_loss, η_loss (only if common conditions exist)
if ~isempty(common_conditions)
    % Process all common conditions
    for cond_idx = 1:length(common_conditions)
        condition = common_conditions(cond_idx);
    
    figure('Position', [100, 100, 1400, 800]);
    
    % Get all year-month combinations and sort them chronologically
    year_month_combinations = [];
    for i = 1:length(all_events_data.year)
        year_month_combinations = [year_month_combinations; all_events_data.year(i), all_events_data.month(i)];
    end
    unique_year_months = unique(year_month_combinations, 'rows');
    unique_year_months = sortrows(unique_year_months, [1, 2]); % Sort by year, then month
    
    n_periods = size(unique_year_months, 1);
    
    % Initialize arrays to store period averages for this condition
    R0_period_avg = zeros(1, n_periods);
    P_loss_period_avg = zeros(1, n_periods);
    eta_loss_period_avg = zeros(1, n_periods);
    period_event_counts = zeros(1, n_periods);
    
    % Calculate period averages for this condition
    for p = 1:n_periods
        year_num = unique_year_months(p, 1);
        month_num = unique_year_months(p, 2);
        period_events_idx = find(all_events_data.year == year_num & all_events_data.month == month_num);
        
        if ~isempty(period_events_idx)
            % Calculate representative values for each event in this condition
            R0_this_period = [];
            P_loss_this_period = [];
            eta_loss_this_period = [];
            
            for event_idx = period_events_idx
                R0_rep = mean(all_events_data.R0_instant{event_idx}(~isnan(all_events_data.R0_instant{event_idx})));
                P_loss_rep = mean(all_events_data.P_loss_instant{event_idx}(~isnan(all_events_data.P_loss_instant{event_idx})));
                eta_loss_rep = mean(all_events_data.eta_loss_instant{event_idx}(~isnan(all_events_data.eta_loss_instant{event_idx})));
                
                R0_this_period = [R0_this_period, R0_rep];
                P_loss_this_period = [P_loss_this_period, P_loss_rep];
                eta_loss_this_period = [eta_loss_this_period, eta_loss_rep * 100];
            end
            
            % Calculate period averages
            R0_period_avg(p) = mean(R0_this_period);
            P_loss_period_avg(p) = mean(P_loss_this_period);
            eta_loss_period_avg(p) = mean(eta_loss_this_period);
            period_event_counts(p) = length(period_events_idx);
        else
            R0_period_avg(p) = NaN;
            P_loss_period_avg(p) = NaN;
            eta_loss_period_avg(p) = NaN;
            period_event_counts(p) = 0;
        end
    end
    
    % Create x-axis labels for periods
    period_labels = cell(1, n_periods);
    for p = 1:n_periods
        year_num = unique_year_months(p, 1);
        month_num = unique_year_months(p, 2);
        period_labels{p} = sprintf('%d-%02d', year_num, month_num);
    end
    
    % Subplot 1: R₀ vs Period
    subplot(1, 3, 1);
    hold on;
    colors = lines(n_periods);
    
    for p = 1:n_periods
        year_num = unique_year_months(p, 1);
        month_num = unique_year_months(p, 2);
        if ~isnan(R0_period_avg(p))
            plot(p, R0_period_avg(p), 'o', ...
                'Color', colors(p, :), 'MarkerSize', 8, 'LineWidth', 0.8, ...
                'MarkerFaceColor', colors(p, :), ...
                'DisplayName', sprintf('%d-%02d (n=%d)', year_num, month_num, period_event_counts(p)));
        end
    end
    
    xlabel('Period (YYYY-MM)');
    ylabel('Average R₀ (Ω)');
    title(sprintf('Common Condition %d: V_start=%.3f-%.3fV, V_fin=%.3f-%.3fV (Total: %d events)', ...
        cond_idx, condition.V_start_bin_start, condition.V_start_bin_end, condition.V_fin_bin_start, condition.V_fin_bin_end, condition.total_events));
    grid on;
    xticks(1:n_periods);
    xticklabels(period_labels);
    legend('Location', 'best');
    
    % Subplot 2: P_loss vs Period
    subplot(1, 3, 2);
    hold on;
    
    for p = 1:n_periods
        year_num = unique_year_months(p, 1);
        month_num = unique_year_months(p, 2);
        if ~isnan(P_loss_period_avg(p))
            plot(p, P_loss_period_avg(p), 's', ...
                'Color', colors(p, :), 'MarkerSize', 8, 'LineWidth', 0.8, ...
                'MarkerFaceColor', colors(p, :), ...
                'DisplayName', sprintf('%d-%02d (n=%d)', year_num, month_num, period_event_counts(p)));
        end
    end
    
    xlabel('Period (YYYY-MM)');
    ylabel('Average P_{loss} (kW)');
    title('Period Average P_{loss}');
    grid on;
    xticks(1:n_periods);
    xticklabels(period_labels);
    legend('Location', 'best');
    
    % Subplot 3: η_loss vs Period
    subplot(1, 3, 3);
    hold on;
    
    for p = 1:n_periods
        year_num = unique_year_months(p, 1);
        month_num = unique_year_months(p, 2);
        if ~isnan(eta_loss_period_avg(p))
            plot(p, eta_loss_period_avg(p), 'd', ...
                'Color', colors(p, :), 'MarkerSize', 8, 'LineWidth', 0.8, ...
                'MarkerFaceColor', colors(p, :), ...
                'DisplayName', sprintf('%d-%02d (n=%d)', year_num, month_num, period_event_counts(p)));
        end
    end
    
    xlabel('Period (YYYY-MM)');
    ylabel('Average η_{loss} (%)');
    title('Period Average η_{loss}');
    grid on;
    xticks(1:n_periods);
    xticklabels(period_labels);
    legend('Location', 'best');
    
        saveas(gcf, fullfile(saveDir, sprintf('common_condition_%d_period_comparison.fig', cond_idx)));
    end
else
    fprintf('No common charging conditions found across all years. Skipping Figure 3.\n');
end

%% Save results
save(fullfile(saveDir, 'power_loss_analysis_results_multi_year.mat'), 'yearly_data', 'all_events_data', 'common_conditions', 'filtered_events_by_year');

fprintf('\nAnalysis completed. Total events processed: %d\n', event_counter);
fprintf('Results saved to: %s\n', saveDir);
fprintf('Figures saved:\n');
if ~isempty(common_conditions)
    year_list = unique(all_events_data.year);
    for y = 1:length(year_list)
        yearnum = year_list(y);
        fprintf('  - best_common_condition_time_series_year_%d.fig\n', yearnum);
    end
    for cond_idx = 1:length(common_conditions)
        fprintf('  - common_condition_%d_R0_Ploss_etaloss_timeseries.fig\n', cond_idx);
        fprintf('  - common_condition_%d_period_comparison.fig\n', cond_idx);
    end
else
    fprintf('  - No common conditions found, no figures generated\n');
end