%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lab Data - Drive Cycle DCIR Analysis (RPT0)
% Event detection and time-based DCIR calculation from real load profile data
% Logic adapted from FieldData_DCIR_Charge_CurrentClustering_Auto.m
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear; clc; close all;

%% Load Data
load('G:\공유 드라이브\Battery Software Lab\0_Group Meeting\개인별_미팅자료\정철원\Experimental Data\Drive Cycle\parsedDriveCycle\parsedDriveCycle_0cyc_filtered.mat');

%% Settings (64Ah cell)
dt_list = [1, 3, 5, 10, 30, 50];
Cnom = 64;  % Battery capacity [Ah]
Pnom = 
current_threshold = Cnom * 0.02;  % Idle current threshold [A]
min_duration      = 10;           % Minimum driving duration [s]
max_P_std         = 0.020;        % Maximum power standard deviation [kW] (cell level)
max_I_std         = Cnom * 0.020;  % Maximum current standard deviation [A]

%% Pulse Detection & DCIR calculation
Lab_DC_DCIR = struct();

channels = fieldnames(parsedDriveCycle_0cyc);
for ch_idx = 1:length(channels)
    channelName = channels{ch_idx};
    channel_data = parsedDriveCycle_0cyc.(channelName);
    soc_levels = fieldnames(channel_data);
    
    chg_struct_name = [channelName '_ChgEvent'];
    dchg_struct_name = [channelName '_DchEvent'];
    if ~isfield(Lab_DC_DCIR, chg_struct_name)
        Lab_DC_DCIR.(chg_struct_name) = struct();
    end
    if ~isfield(Lab_DC_DCIR, dchg_struct_name)
        Lab_DC_DCIR.(dchg_struct_name) = struct();
    end
    
    for soc_idx = 1:length(soc_levels)
        soc_level = soc_levels{soc_idx};
        soc_data = channel_data.(soc_level);
        profiles = fieldnames(soc_data);
        
        if ~isfield(Lab_DC_DCIR.(chg_struct_name), soc_level)
            Lab_DC_DCIR.(chg_struct_name).(soc_level) = struct();
        end
        if ~isfield(Lab_DC_DCIR.(dchg_struct_name), soc_level)
            Lab_DC_DCIR.(dchg_struct_name).(soc_level) = struct();
        end
        
        for prof_idx = 1:length(profiles)
            profile_name = profiles{prof_idx};
            profile_data = soc_data.(profile_name);
            
            if ~isfield(Lab_DC_DCIR.(chg_struct_name).(soc_level), profile_name)
                Lab_DC_DCIR.(chg_struct_name).(soc_level).(profile_name) = struct();
            end
            if ~isfield(Lab_DC_DCIR.(dchg_struct_name).(soc_level), profile_name)
                Lab_DC_DCIR.(dchg_struct_name).(soc_level).(profile_name) = struct();
            end
            
            V = profile_data.V;
            I = profile_data.I;
            t = profile_data.t;
            totalTime = profile_data.totalTime;
            stepIndex = profile_data.stepIndex;
            
            if isa(t, 'duration')
                t_seconds = seconds(t);
            else
                t_seconds = t;
            end
            
            %% Step 1: Idle -> Load transition detection
            is_idle = abs(I) < current_threshold;
            is_driving = abs(I) >= current_threshold;
            
            idle_to_driving = find(is_idle(1:end-1) & is_driving(2:end));
            
            if isempty(idle_to_driving)
                continue;  % Skip if no transition
            end
            
            %% Step 2: Event Detection (charging/discharging split)
            chg_event_count = 0;
            dchg_event_count = 0;
            for i = 1:length(idle_to_driving)
                idx1 = idle_to_driving(i);
                start_driving_idx = idx1 + 1;
                
                % Find end index of driving
                driving_end_idx = start_driving_idx;
                while driving_end_idx <= length(is_driving) && is_driving(driving_end_idx)
                    driving_end_idx = driving_end_idx + 1;
                end
                driving_end_idx = driving_end_idx - 1;
                
                start_idx = idx1;
                end_idx = driving_end_idx;
                
                % Check driving duration (actual time)
                driving_time = t_seconds(driving_end_idx) - t_seconds(start_driving_idx);
                if driving_time < min_duration
                    continue;
                end
                
                % Extract segment
                t_seg = t_seconds(start_idx:end_idx);
                I_seg = I(start_idx:end_idx);
                V_seg = V(start_idx:end_idx);
                
                P_seg = V_seg .* I_seg / 1000;  % [kW]
                
                % idx2: end of driving segment
                idx2 = driving_end_idx - start_idx + 1;
                
                %% Step 3: Stability check
                power_std   = std(P_seg(3:idx2-2));
                current_std = std(I_seg(3:idx2-2));
                
                if power_std >= max_P_std || current_std >= max_I_std
                    fprintf('    → FILTERED: Power & Current instability (std=%.1fkW > %.1fkW) | (std=%.1fA > %.1fA)\n', power_std, max_P_std, current_std, max_I_std);
                    continue;
                end                   
                
                % Charging/discharging split
                if mean(I_seg) > 0
                    chg_event_count = chg_event_count + 1;
                    evtName = sprintf('event%d', chg_event_count);
                    target_struct = Lab_DC_DCIR.(chg_struct_name);
                elseif mean(I_seg) < 0
                    dchg_event_count = dchg_event_count + 1;
                    evtName = sprintf('event%d', dchg_event_count);
                    target_struct = Lab_DC_DCIR.(dchg_struct_name);
                else
                    continue;
                end
                % Store event in the appropriate structure
                target_struct.(soc_level).(profile_name).(evtName).channel = channelName;
                target_struct.(soc_level).(profile_name).(evtName).soc_level = soc_level;
                target_struct.(soc_level).(profile_name).(evtName).profile_name = profile_name;
                target_struct.(soc_level).(profile_name).(evtName).stepIndex = stepIndex;
                target_struct.(soc_level).(profile_name).(evtName).event_number = str2double(evtName(6:end));
                target_struct.(soc_level).(profile_name).(evtName).transition_idx = idx1;
                target_struct.(soc_level).(profile_name).(evtName).driving_duration = driving_time;
                target_struct.(soc_level).(profile_name).(evtName).t = t_seg;
                target_struct.(soc_level).(profile_name).(evtName).I = I_seg;
                target_struct.(soc_level).(profile_name).(evtName).V = V_seg;
                target_struct.(soc_level).(profile_name).(evtName).P = P_seg;
                target_struct.(soc_level).(profile_name).(evtName).I_std = current_std;
                target_struct.(soc_level).(profile_name).(evtName).P_std = power_std;
                for dt_idx = 1:length(dt_list)
                    dt_sec = dt_list(dt_idx);
                    if length(t_seg) > 1
                        dt = t_seg(2) - t_seg(1); % Sample interval
                        idx_dt = round(dt_sec / dt + 1); % Integer index
                    else
                        idx_dt = 1;
                    end
                    if idx_dt <= length(I_seg)
                        V1 = V_seg(1);
                        V2 = V_seg(idx_dt);
                        I1 = I_seg(1);
                        I2 = I_seg(idx_dt);
                        dV = V2 - V1;
                        dI = I2 - I1;
                        if dI > 0 && dV > 0
                            dcir_val = (dV / dI) * 1000;
                        elseif dI < 0 && dV < 0
                            dcir_val = (dV / dI) * 1000;
                        else
                            dcir_val = NaN;
                        end
                    else
                        V1 = NaN; V2 = NaN; I1 = NaN; I2 = NaN;
                        dV = NaN; dI = NaN;
                        dcir_val = NaN;
                    end
                    fieldName = sprintf('DCIR_%ds', dt_sec);
                    target_struct.(soc_level).(profile_name).(evtName).(fieldName).val = dcir_val;
                    target_struct.(soc_level).(profile_name).(evtName).(fieldName).V1 = V1;
                    target_struct.(soc_level).(profile_name).(evtName).(fieldName).V2 = V2;
                    target_struct.(soc_level).(profile_name).(evtName).(fieldName).I1 = I1;
                    target_struct.(soc_level).(profile_name).(evtName).(fieldName).I2 = I2;
                    target_struct.(soc_level).(profile_name).(evtName).(fieldName).dV = dV;
                    target_struct.(soc_level).(profile_name).(evtName).(fieldName).dI = dI;
                end
                % Save back to main structure
                if mean(I_seg) > 0
                    Lab_DC_DCIR.(chg_struct_name) = target_struct;
                else
                    Lab_DC_DCIR.(dchg_struct_name) = target_struct;
                end
            end
        end
    end
end

%% Save results
save('Lab_DC_DCIR_Events.mat', 'Lab_DC_DCIR');

%% Simple statistics
total_events = 0;

% Count events and collect DCIR_1s values
channels = fieldnames(Lab_DC_DCIR);
for ch_idx = 1:length(channels)
    channelName = channels{ch_idx};
    soc_levels = fieldnames(Lab_DC_DCIR.(channelName));
    
    for soc_idx = 1:length(soc_levels)
        soc_level = soc_levels{soc_idx};
        profiles = fieldnames(Lab_DC_DCIR.(channelName).(soc_level));
        
        for prof_idx = 1:length(profiles)
            profile_name = profiles{prof_idx};
            events = fieldnames(Lab_DC_DCIR.(channelName).(soc_level).(profile_name));
            
            for evt_idx = 1:length(events)
                evt_name = events{evt_idx};
                evt_data = Lab_DC_DCIR.(channelName).(soc_level).(profile_name).(evt_name);
                
                total_events = total_events + 1;                                
            end
        end
    end
end

fprintf('Total events: %d\n', total_events);

% Print DCIR statistics for 1s, 5s, 10s, 30s
for t = [1, 5, 10, 30]
    dcir_values = [];
    field_name = sprintf('DCIR_%ds', t);
    for ch_idx = 1:length(channels)
        channelName = channels{ch_idx};
        soc_levels = fieldnames(Lab_DC_DCIR.(channelName));
        for soc_idx = 1:length(soc_levels)
            soc_level = soc_levels{soc_idx};
            profiles = fieldnames(Lab_DC_DCIR.(channelName).(soc_level));
            for prof_idx = 1:length(profiles)
                profile_name = profiles{prof_idx};
                events = fieldnames(Lab_DC_DCIR.(channelName).(soc_level).(profile_name));
                for evt_idx = 1:length(events)
                    evt_name = events{evt_idx};
                    evt_data = Lab_DC_DCIR.(channelName).(soc_level).(profile_name).(evt_name);
                    if isfield(evt_data, field_name)
                        dcir_val = evt_data.(field_name).val;
                        if ~isnan(dcir_val)
                            dcir_values = [dcir_values, dcir_val];
                        end
                    end
                end
            end
        end
    end
    if ~isempty(dcir_values)
        fprintf('DCIR_%ds mean: %.2f ± %.2f mΩ (n=%d)\n', ...
            t, mean(dcir_values), std(dcir_values), length(dcir_values));
    end
end

fprintf('Analysis completed\n');

%% Start Visualization
fprintf('Starting visualization script...\n');
DriveCycle_DCIR_Visualization; 