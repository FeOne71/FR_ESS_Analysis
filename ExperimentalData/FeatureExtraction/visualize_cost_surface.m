%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Cost Surface Visualization Script for ECM 2RC Fitting Results
%
% Purpose: Generate Cost Surface visualizations from saved ECM fitting results
% This script loads saved fitting results and creates tau1-tau2 cost surface plots
%
% Usage: 
%   1. Run ecm_fitting_drive_cycle_1029.m first to generate fitting results
%   2. Modify configuration section below to select target results
%   3. Run this script to generate cost surface visualizations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear; clc; close all;

%% Configuration
% =========================================================================
fprintf('=== Cost Surface Visualization Script Started ===\n');

% Result file path (generated by ecm_fitting_drive_cycle_1029.m)
% Note: Results are now saved in channel-specific folders: Results/ECM_Fitting/{channel_name}/
channel_name_for_results = 'ch9';  % Modify as needed (e.g., 'ch9', 'ch16', etc.)
results_dir = fullfile('Results', 'ECM_Fitting', channel_name_for_results);
results_file = sprintf('ECM_2RC_Fitting_Results_%s.mat', channel_name_for_results);

% OCV data path (needed to regenerate OCV_vec from SOC)
ocv_data_path = 'D:\JCW\Projects\KEPCO_ESS_Local\ExperimentalData\RPT\Postprocessing\OCV_integrated\OCV_integrated.mat';

% Parameter bounds (should match main fitting script)
lb = [0, 0, 0, 0.01, 0.01];   % Lower bound
ub = [0.05, 0.005, 0.03, 100, 5000];   % Upper bound

% Cost surface grid resolution
tau1_points = 31;  % Number of points for tau1 grid
tau2_points = 31;  % Number of points for tau2 grid

% Select which results to visualize (empty = all results)
% Format: {'SOC50_DC1_Cycle0', 'SOC50_DC1_Cycle200', ...}
% Leave empty to process all results
TARGET_RESULTS = {};  % Empty = process all

fprintf('Loading results from: %s\n', fullfile(results_dir, results_file));

%% Load Data
% =========================================================================
results_path = fullfile(results_dir, results_file);
if ~exist(results_path, 'file')
    error('Results file not found: %s', results_path);
end

loaded_data = load(results_path);
if ~isfield(loaded_data, 'ecm_results')
    error('ecm_results not found in results file');
end

ecm_results = loaded_data.ecm_results;

% Load OCV data for OCV_vec regeneration
load(ocv_data_path);
if ~exist('OCV_data', 'var')
    error("'OCV_data' variable not found.");
end

fprintf('Results loaded successfully\n');

%% Process Each Result
% =========================================================================
result_keys = fieldnames(ecm_results);

if ~isempty(TARGET_RESULTS)
    % Filter to only selected results
    result_keys = intersect(result_keys, TARGET_RESULTS);
end

if isempty(result_keys)
    fprintf('No results to process.\n');
    return;
end

fprintf('\nProcessing %d result(s)...\n', length(result_keys));

for result_idx = 1:length(result_keys)
    result_key = result_keys{result_idx};
    result_data = ecm_results.(result_key);
    
    fprintf('\n--- Processing %s ---\n', result_key);
    
    % Extract data from result structure
    cycle_num = result_data.Cycle;
    soc_name = sprintf('SOC%d', result_data.SOC_target);
    dc_name = result_data.DC_profile;
    
    % Determine channel name from result key or use default
    channel_match = regexp(result_key, 'ch(\d+)', 'tokens');
    if ~isempty(channel_match)
        channel_name = ['ch' channel_match{1}{1}];
    else
        channel_name = 'ch9';  % Default
    end
    
    % Extract measurement data
    I_measured = result_data.I_measured;
    V_measured = result_data.V_measured;
    t_measured = result_data.t_measured;
    SOC_full = result_data.SOC;
    params_optimal = [result_data.R0, result_data.R1, result_data.R2, result_data.tau1, result_data.tau2];
    
    % Debug: Display fitted parameters for this cycle
    fprintf('  [DEBUG] Cycle %d Fitted Parameters:\n', cycle_num);
    fprintf('    R0 = %.6f Ω, R1 = %.6f Ω, R2 = %.6f Ω\n', params_optimal(1), params_optimal(2), params_optimal(3));
    fprintf('    tau1 = %.3f s, tau2 = %.3f s\n', params_optimal(4), params_optimal(5));
    fprintf('    RMSE = %.6f V (%.4f mV)\n', result_data.rmse, result_data.rmse*1000);
    
    % Regenerate OCV_vec from SOC_full using OCV_integrated data
    ocv_field_name = sprintf('OCV_integrated_%d', cycle_num);
    if isfield(OCV_data, ocv_field_name)
        ocv_integrated_data = OCV_data.(ocv_field_name);
        fprintf('  Using %s OCV data\n', ocv_field_name);
        
        % Generate OCV_vec using OCV_SOC_func
        if isfield(ocv_integrated_data, 'OCV_SOC_func')
            OCV_vec = ocv_integrated_data.OCV_SOC_func(SOC_full);
        else
            % Fallback: create interpolation function
            fprintf('  Warning: OCV_SOC_func not found. Creating interpolation function...\n');
            soc_grid_points = ocv_integrated_data.SOC_grid;
            ocv_values_at_soc_grid = ocv_integrated_data.V_avg_SOC;
            [ocv_values_sorted, uniqueIdx] = unique(ocv_values_at_soc_grid, 'stable');
            soc_grid_sorted = soc_grid_points(uniqueIdx);
            soc_to_ocv_interp_func = @(soc) interp1(soc_grid_sorted, ocv_values_sorted, soc, 'linear', 'extrap');
            OCV_vec = soc_to_ocv_interp_func(SOC_full);
        end
    else
        fprintf('  Error: %s OCV data not found. Skipping this result.\n', ocv_field_name);
        continue;
    end
    
    % Generate cost surface
    fprintf('  Calculating Cost Surface...\n');
    create_cost_surface_visualization(channel_name, soc_name, dc_name, cycle_num, ...
        I_measured, V_measured, t_measured, OCV_vec, params_optimal, lb, ub, ...
        tau1_points, tau2_points);
end

fprintf('\n=== Cost Surface Visualization Completed ===\n');

%% Helper Functions
% =========================================================================

function create_cost_surface_visualization(channel_name, soc_name, dc_name, cycle_num, ...
    I_measured, V_measured, t_measured, OCV_vec, params_optimal, lb, ub, ...
    tau1_points, tau2_points)
    % Cost Surface visualization function (based on BSL Reference method)
    % Optimize only R0, R1, R2 at each point in tau1, tau2 grid
    
    % Generate tau1, tau2 grid (log scale, BSL Reference method)
    tau1_vec = 10.^(linspace(log10(lb(4)), log10(ub(4)), tau1_points));
    tau2_vec = 10.^(linspace(log10(lb(5)), log10(ub(5)), tau2_points));
    
    % Initialize cost surface matrix
    cost_surface = zeros(length(tau2_vec), length(tau1_vec));
    
    % fmincon options (reference method)
    options_R = optimset( ...
        'Display', 'off', ...
        'MaxIter', 3000, ...
        'MaxFunEvals', 1e5, ...
        'TolFun', 1e-14, ...
        'TolX', 1e-15);
    
    % Optimize at each grid point
    total_points = length(tau1_vec) * length(tau2_vec);
    point_count = 0;
    
    fprintf('    Progress: ');
    for ii = 1:length(tau1_vec)
        for jj = 1:length(tau2_vec)
            tau1_fixed = tau1_vec(ii);
            tau2_fixed = tau2_vec(jj);
            
            % Check tau1 < tau2 constraint
            if tau1_fixed >= tau2_fixed
                cost_surface(jj, ii) = Inf;  % Invalid combination
                continue;
            end
            
            % Initial values (reference method: all 5 parameters passed, tau1, tau2 fixed)
            p0_R = [params_optimal(1), params_optimal(2), params_optimal(3), tau1_fixed, tau2_fixed];
            
            % Bounds (reference method: tau1, tau2 fixed to same value as bounds)
            % ub_R: R0, R1, R2 set to 10 times initial values (reference method)
            lb_R = [0, 0, 0, tau1_fixed, tau2_fixed];
            ub_R = [p0_R(1)*10, p0_R(2)*10, p0_R(3)*10, tau1_fixed, tau2_fixed];
            
            % Execute optimization (reference method: all 5 parameters passed but tau1, tau2 fixed via bounds)
            [~, fval] = fmincon( ...
                @(p) ecm_cost_function(p, I_measured, V_measured, t_measured, OCV_vec), ...
                p0_R, [],[],[],[], lb_R, ub_R, [], options_R);
            cost_surface(jj, ii) = fval;
            
            point_count = point_count + 1;
            if mod(point_count, 100) == 0
                fprintf('.');
            end
        end
    end
    fprintf(' Done\n');
    
    fprintf('    Cost Surface calculation completed\n');
    
    % Find optimal point (considering only valid values)
    valid_mask = ~isinf(cost_surface) & ~isnan(cost_surface);
    best_tau1 = [];
    best_tau2 = [];
    min_cost = [];
    fitted_cost = [];
    
    if any(valid_mask(:))
        % Find minimum among valid values
        valid_costs = cost_surface(valid_mask);
        [min_cost, min_idx] = min(valid_costs);
        valid_linear_idx = find(valid_mask);
        [r, c] = ind2sub(size(cost_surface), valid_linear_idx(min_idx));
        best_tau1 = tau1_vec(c);
        best_tau2 = tau2_vec(r);
        
        % Recalculate optimal R0, R1, R2 for Grid Optimal tau1, tau2
        p0_R_grid = [params_optimal(1), params_optimal(2), params_optimal(3), best_tau1, best_tau2];
        lb_R_grid = [0, 0, 0, best_tau1, best_tau2];
        ub_R_grid = [p0_R_grid(1)*10, p0_R_grid(2)*10, p0_R_grid(3)*10, best_tau1, best_tau2];
        [params_grid_optimal, ~] = fmincon( ...
            @(p) ecm_cost_function(p, I_measured, V_measured, t_measured, OCV_vec), ...
            p0_R_grid, [],[],[],[], lb_R_grid, ub_R_grid, [], options_R);
        
        % Calculate actual fitted cost
        fitted_cost = ecm_cost_function(params_optimal, I_measured, V_measured, t_measured, OCV_vec);
        
        % Compare Grid Optimal vs Fitted
        fprintf('    [DEBUG] Grid Optimal (from Cost Surface):\n');
        fprintf('      R0 = %.6f Ω, R1 = %.6f Ω, R2 = %.6f Ω\n', params_grid_optimal(1), params_grid_optimal(2), params_grid_optimal(3));
        fprintf('      tau1 = %.3f s, tau2 = %.3f s\n', best_tau1, best_tau2);
        fprintf('      RMSE = %.6f V (%.4f mV)\n', min_cost, min_cost*1000);
        
        fprintf('    [DEBUG] Fitted (MultiStart):\n');
        fprintf('      R0 = %.6f Ω, R1 = %.6f Ω, R2 = %.6f Ω\n', params_optimal(1), params_optimal(2), params_optimal(3));
        fprintf('      tau1 = %.3f s, tau2 = %.3f s\n', params_optimal(4), params_optimal(5));
        fprintf('      RMSE = %.6f V (%.4f mV)\n', fitted_cost, fitted_cost*1000);
        
        cost_diff = fitted_cost - min_cost;
        fprintf('    [DEBUG] Comparison:\n');
        if cost_diff > 0
            fprintf('      -> Grid Optimal is %.6f V (%.4f mV) better\n', cost_diff, cost_diff*1000);
            fprintf('      -> MultiStart may be stuck in local minimum\n');
        elseif cost_diff < 0
            fprintf('      -> Fitted is %.6f V (%.4f mV) better\n', -cost_diff, -cost_diff*1000);
            fprintf('      -> Grid search missed better solution\n');
        else
            fprintf('      -> Both methods found the same solution\n');
        end
        fprintf('      -> Difference: %.6f V (%.4f mV)\n', abs(cost_diff), abs(cost_diff)*1000);
    end
    
    % Create meshgrid for plotting
    [T1, T2] = meshgrid(tau1_vec, tau2_vec);
    
    % Create figure with subplots (3D and 2D)
    figure('Position', [100, 100, 1400, 600]);
    
    % === Subplot 1: 3D Surface Plot ===
    subplot(1, 2, 1);
    surf(T1, T2, cost_surface, 'EdgeColor', 'none', 'FaceColor', 'interp');
    view(3);
    xlabel('\tau_1 [s]', 'FontWeight', 'bold');
    ylabel('\tau_2 [s]', 'FontWeight', 'bold');
    zlabel('RMSE [V]', 'FontWeight', 'bold');
    colorbar;
    shading interp;
    hold on;
    
    if ~isempty(best_tau1)
        % Plot optimal point (grid minimum)
        hStar = plot3(best_tau1, best_tau2, min_cost, 'r*', ...
            'MarkerSize', 15, 'LineWidth', 2);
        
        % Plot actual fitting result point
        hActual = plot3(params_optimal(4), params_optimal(5), fitted_cost, ...
            'go', 'MarkerSize', 12, 'LineWidth', 2);
        
        % Legend (with RMSE values)
        legend([hStar, hActual], ...
            sprintf('Grid Optimal: \\tau_1=%.3f, \\tau_2=%.3f (RMSE=%.4f mV)', best_tau1, best_tau2, min_cost*1000), ...
            sprintf('Fitted: \\tau_1=%.3f, \\tau_2=%.3f (RMSE=%.4f mV)', params_optimal(4), params_optimal(5), fitted_cost*1000), ...
            'Location', 'best');
    end
    hold off;
    title('3D Cost Surface', 'FontWeight', 'bold');
    
    % Set axis colors to black
    ax = gca;
    ax.XColor = 'k';
    ax.YColor = 'k';
    ax.ZColor = 'k';
    
    % === Subplot 2: 2D Contour Plot ===
    subplot(1, 2, 2);
    contourf(T1, T2, cost_surface, 20, 'LineColor', 'none');
    colorbar;
    xlabel('\tau_1 [s]', 'FontWeight', 'bold');
    ylabel('\tau_2 [s]', 'FontWeight', 'bold');
    hold on;
    
    if ~isempty(best_tau1)
        % Plot optimal point (grid minimum)
        hStar = plot(best_tau1, best_tau2, 'r*', ...
            'MarkerSize', 15, 'LineWidth', 2);
        
        % Plot actual fitting result point
        hActual = plot(params_optimal(4), params_optimal(5), ...
            'go', 'MarkerSize', 12, 'LineWidth', 2);
        
        % Legend (with RMSE values)
        legend([hStar, hActual], ...
            sprintf('Grid Optimal: \\tau_1=%.3f, \\tau_2=%.3f (RMSE=%.4f mV)', best_tau1, best_tau2, min_cost*1000), ...
            sprintf('Fitted: \\tau_1=%.3f, \\tau_2=%.3f (RMSE=%.4f mV)', params_optimal(4), params_optimal(5), fitted_cost*1000), ...
            'Location', 'best');
    end
    hold off;
    title('2D Contour Plot', 'FontWeight', 'bold');
    
    % Set axis colors to black
    ax = gca;
    ax.XColor = 'k';
    ax.YColor = 'k';
    
    % Overall title
    sgtitle(sprintf('%s-%s-%s-Cycle%d: \\tau_1-\\tau_2 Cost Surface', channel_name, soc_name, dc_name, cycle_num), ...
        'FontSize', 14, 'FontWeight', 'bold');
    
    % Save visualization (channel-specific folder)
    save_dir = fullfile('Results', 'Cost_Surface', channel_name);
    if ~exist(save_dir, 'dir'), mkdir(save_dir); end
    
    fig_filename = sprintf('%s_%s_%s_Cycle%d_CostSurface.fig', channel_name, soc_name, dc_name, cycle_num);
    fig_path = fullfile(save_dir, fig_filename);
    savefig(fig_path);
    
    fprintf('    Cost Surface saved: %s\n', fig_filename);
    
    % Close figure to save memory
    close(gcf);
end

function cost = ecm_cost_function(params, I, V_measured, t, OCV_vec)
    % ECM 2RC model cost function
    % Input: params, I (current), V_measured, t (time), OCV_vec (pre-calculated OCV vector)
    V_model = ecm_2rc_model(params, I, t, OCV_vec);
    residual = V_measured - V_model;
    cost = sqrt(mean(residual.^2));  % RMSE
end

function V_terminal = ecm_2rc_model(params, I, t, OCV_vec)
    % ECM 2RC model function
    % Input: params [R0, R1, R2, tau1, tau2], I (current), t (time), OCV_vec (pre-calculated OCV vector)
    
    % Extract parameters
    R0 = params(1);
    R1 = params(2);
    R2 = params(3);
    tau1 = params(4);
    tau2 = params(5);
    
    % Calculate time intervals
    % dt = diff(t) creates [t(2)-t(1), t(3)-t(2), ...] with length N-1
    % dt(k-1) represents the time interval between k-1 and k
    dt = diff(t);
    
    N = length(t);
    V_terminal = zeros(N, 1);
    
    % Initialize RC network state variables
    Vrc1 = 0;
    Vrc2 = 0;
    
    for k = 1:N
        % Use pre-calculated OCV value
        V_oc = OCV_vec(k);
        
        % R0 voltage drop
        IR0 = R0 * I(k);
        
        if k == 1
            % Initial state: Vrc1 and Vrc2 are zero
            Vrc1 = 0;
            Vrc2 = 0;
        else
            % Update RC1, RC2 using actual time intervals
            % dt(k-1) is the time interval between k-1 and k
            % I(k-1) is the current at time k-1
            alpha1 = exp(-dt(k-1)/tau1);
            alpha2 = exp(-dt(k-1)/tau2);
            Vrc1 = Vrc1*alpha1 + R1*(1 - alpha1)*I(k-1);
            Vrc2 = Vrc2*alpha2 + R2*(1 - alpha2)*I(k-1);
        end
        
        % Final voltage
        V_terminal(k) = V_oc + IR0 + Vrc1 + Vrc2;
    end
end

